Структура данных (англ. data structure) — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных

Для работы с коллекциями используется специальный Collection Framework - java.util.Collection

Коллекции в Java состоят нескольких частей:
    1) Интерфейсы: В коллекциях интерфейсы обеспечивают абстрактный тип данных для представления коллекции java.util.Collection — корневого интерфейса фреймворка.
    Он находится на вершине иерархии Коллекций. Он содержит наиболее важные методы:  size(), iterator(), add(), remove(), clear().
    Каждая коллекция должна реализовывать эти методы. Также есть другие важные интерфейсы java.util.List, java.util.Set,java.util.Queue и java.util.Map.
     Map является единственным интерфейсом, который не наследует интерфейс Collection, но является неотъемлемой частью коллекций.
     Все интерфейсы фреймворка находятся в пакете java.util.
    2) Реализация: Java предоставляет готовые классы с реализацией вышеупомянутых коллекций.
    Мы можем использовать их для создания новых типов коллекций в нашей программе.
    С помощью классов ArrayList, LinkedList, HashMap, TreeMap, HashSet, TreeSet можно решить огромное количество задач,
    но если нужна специальная реализация той или иной коллекции, можно наследовать её и работать со своей реализацией.
    3) Методы, которые решают тривиальные задачи, например: поиск, сортировка и перетасовка элементов коллекции.


Интерфейсы являются основой Java Collections Framework.
Все интерфейсы являются Generic.

java.util.Collection

по соглашению все коллекции имеют конструктор, который принимает интерфейс Collection в качестве параметра.
Такой конструктор инициализирует новую коллекцию всеми элементами из указанной коллекции,
то есть позволяет конвертировать один тип коллекций в другой.

int size(); Возвращает количество элементов в коллекции.

boolean isEmpty() Возвращает true, если в коллекции нет ни одного элемента.

boolean contains(Object element) Возвращает true, если коллекция содержит элемент element.

boolean add(E element) Добавляет элемент в коллекцию. Возвращает true, если элемент был добавлен.
Возвращает false, если коллекция не может содержать дублирующихся элементов, и такой элемент уже в ней есть.

boolean remove(Object element) Удаляет одно вхождение element из коллекции.
Возвращает true, если элемент был удалён, false — коллекция не была изменена.

Также есть методы, которые оперируют целыми коллекциями:
boolean containsAll(Collection<?> c)  Возвращает true, если коллекция содержит все элементы из c.

boolean addAll(Collection<? extends E> c) Добавляет все элементы из c в коллекцию.

boolean removeAll(Collection<?> c)  Удаляет из коллекции все элементы, которые присутствуют в c.

boolean retainAll(Collection<?> c) Оставляет в коллекции только те элементы, которые также присутствуют в коллекции c , удаляя все остальные.

void clear() Удаляет все элементы из коллекции.

Есть также методы, позволяющие преобразовать коллекцию в массив:
Object[] toArray()
 <T> T[] toArray(T[] a)
Рекомендуется использовать второй метод, так как он позволяет преобразовать в массив определённого типа.
Пример: String[] array = collection.toArray(new String[0]);.

Для прохода по элементам коллекции можно использовать for-each
for (Object o : collection)
System.out.println(o);


Интерфейс итератора (Iterator)
Итератор предоставляет методы для перебора элементов любой коллекции.
Можно получить экземпляр итератора из коллекции с помощью метода iterator().
Итераторы позволяют удалить элементы из базовой коллекции во время выполнения итерации.

1. Интерфейс Set
java.util.Set — это коллекция, которая не может содержать дублирующихся элементов.
Интерфейс Set содержит только методы, унаследованные от java.util.Collection, и добавляет ограничение, что элементы не дублируются.
Set накладывает более строгие соглашения на методы equals и hashCode, что позволяет сравнивать экземпляры Set, даже если они различных реализаций.
Два экземпляра Set равны, если у них одинаковое количество элементов, и они содержат одинаковые элементы.

С помощью Set можно удалить из любой коллекции дублирующиеся элементы. Например, мы хотим удалить дублирующиеся элементы из коллекции c:
Collection<Type> noDups = new HashSet<Type>(c);

В множествах Set каждый элемент хранится только в одном экземпляре, а разные реализации Set используют разный порядок хранения элементов.
В HashSet порядок элементов определяется по сложному алгоритму. Если порядок хранения для вас важен, используйте контейнер TreeSet, в котором объекты хранятся отсортированными по возрастанию в порядке сравнения или LinkedHashSet с хранением элементов в порядке добавления.

Множества часто используются для проверки принадлежности, чтобы вы могли легко проверить, принадлежит ли объект заданному множеству,
поэтому на практике обычно выбирается реализация HashSet, оптимизированная для быстрого поиска.

Платформа Java предоставляет три реализации интерфейса:
HashSet— реализация на основе хеш-таблицы. Это наиболее эффективная реализация, но она не гарантирует сохранение порядка элементов при обходе.
TreeSet— реализация на основе красно-чёрных деревьев. Она упорядочивает элементы в соответствии с их значениями, но работает значительно медленнее HashSet.
LinkedHashSet — реализация на основе хеш-таблицы, но дополнительно пролинкованная связанным списком.
Эта реализация избавляет от хаотичного порядка элементов  и лишь незначительно хуже по эффективности HashSet-а.


2.Интерфейс SortedSet
SortedSet представляет собой множество, в котором элементы хранятся в порядке возрастания.

3. Интерфейс Список (List)
java.util.List
Список (связный список) – это структура данных, представляющая собой конечное множество упорядоченных элементов, связанных друг с другом посредствам указателей.
Каждый элемент структуры содержит поле с какой-либо информацией, а также указатель на следующий (и предыдцщий) элемент.
Список представляет собой упорядоченный набор элементов и может содержать повторяющиеся элементы.
Можно получить доступ к любому элементу по индексу.

Java содержит два класса, реализующих интерфейс List:
java.util.ArrayList
java.util.LinkedList.

Интерфейс java.util.List представляет собой упорядоченную коллекцию.
List может содержать дублирующиеся элементы.
В дополнение к методам java.util.Collection интерфейс java.util.List содержит методы для:

Доступ/удаление/добавление элементов по позиции.
Поиск элемента
Расширенный итератор, позволяющий возвращаться к предыдущему элементу и вставлять новые элементы.

Интерфейс ListIterator
ListIterator (итератор для списков) позволяет проходить список в любом направлении, изменять список во итерации,
и получать текущую позицию итератора в списке.

ListIterator<E> listIterator() Этот итератор наследуется от обычного итератора, но также имеет метод previous(),
позволяющий вернуться к предыдущему элементу, и метод hasPrevious(), позволяющий проверить наличие предыдущего элемента для
текущей позиции итерации.
Вызовы next() и previous() можно чередовать, но нужно быть осторожным, так как первый вызов previous()
после череды вызовов next() вернёт то же значение, что и последний вызов next(), а первый вызов next() после череды previous() вернёт то же значение,
что и последний вызов previous().
Методы previousIndex() и nextIndex() используются для получения индекса элементы, который будет возвращён
следующим вызовом previous() и next() соответственно. Если мы находимся в самом начале списка, то есть следующий вызов next() вернёт первый элемент,
то вызов previousIndex() вернёт -1. Если же мы находимся в конце списка, то есть hasNext() возвращает false, то nextIndex() вернёт значение list.size().
Он также имеет дополнительные методы set и add , которые позволяют заменить последний возвращённый элемент и добавить новый элемент соответственно.

Метод subList позволяет выполнять операции над частью списка - List<E> subList(int fromIndex, int toIndex)
Возвращает часть списка между fromIndex (включая) и toIndex (исключая). Изменения в возвращаемом списке отражаются в исходном списке.
Например, с помощью кода list.subList(from, to).clear(); можно удалить элементы из исходного списка.

Поведение возвращённого списка становится непредсказуемым, если элементы в этом диапазоне будут удалены или добавлены в исходный список,
все изменения нужно делать через возвращённый список, будьте внимательны.

Если необходимо вставлять (или удалять) в середину коллекции много элементов, то лучше использовать LinkedList. Во всех остальных случаях – ArrayList.
LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента
хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто идут по порядку

4. Интерфейс Очередь (Queue)
java.util.Queue
Очередь — коллекция, которая используется для хранения нескольких элементов.
В очереди обычно, но не обязательно, элементы располагаются по принципу FIFO (first-in, first-out = первый вошел, первый вышел).
В очереди FIFO, все новые элементы вставляются в конец очереди.

Обобщенный интерфейс Queue<E> расширяет базовый интерфейс Collection и определяет поведение класса в качестве однонаправленной очереди.
Свою функциональность он раскрывает через следующие методы:
E element(): возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException
boolean offer(E obj): добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false
E peek(): возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null
E poll(): возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null
E remove(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException

Таким образом, у всех классов, которые реализуют данный интерфейс, будет метод offer для добвления в очередь,
метод poll для извлечения элемента из головы очереди,
и методы peek и element, позволяющие просто получить элемент из головы очереди.

5. Интерфейс Dequeue
Коллекция Dequeue поддерживает вставку элемента и удаление элемента как в начало, так и в конец коллекции.
Название Deque это сокращение от «двухконцевой очереди» и, как правило, произносится как «deck».
Большинство реализаций DEQUE не устанавливают ограничения на количество элементов.
Этот интерфейс определяет методы для доступа к элементам на концах дека. Методы предоставляются для вставки, удаления, извлечения элемента.

Интерфейс Map
В контейнерах Map хранятся 2 объекта: ключ и значение
Ключи должны быть уникальны, значения могут дублироваться
Существует возможность искать объекты по ключу

1. Интерфейс Sortedmap расширяет интерфейс Map и гарантирует, что элементы размещаются в возрастающем порядке значений ключей.
2. Интерфейс NavigableMap расширяет интерфейс Sortedmap и определяет поведение отображения,
поддерживающее извлечение элементов на основе ближайшего соответствия заданному ключу или ключам.
3. Интерфейс Map.Entry позволяет работать с элементом отображения.

interface Map<K, V>
В параметре K указывается тип ключей, в V - тип хранимых значений.
Интерфейс Map предоставляет три способа для доступа к данным:
* используя Set из ключей (метод keySet)
* коллекцию из значений (метод values)
* Set из пары ключ-значение (метод entrySet).


Порядок элементов в Map зависит от реализации интерфейса.


void clear() - удаляет все пары "ключ-значение" из вызывающего отображения

boolean containsKey(Object k) - возвращает значение true, если вызывающее отображение содержит ключ k. В противном случае возвращает false

boolean containsValue(Object v) - возвращает значение true, если вызывающее отображение содержит значение v. В противном случае возвращает false

Set<Map.Entry<K, V>> entrySet() - возвращает набор, содержащий все значения отображения. Набор содержит объекты интерфейса Map.Entry. Т.е. метод представляет отображение в виде набора

boolean equals(Object o) - возвращает значение true, если параметр o - это отображение, содержащее одинаковые значения. В противном случае возвращает false

V get(Object k) - возвращает значение, ассоциированное с ключом k. Возвращает значение null, если ключ не найден.

int hashCode() - возвращает хеш-код вызывающего отображения

boolean isEmpty() - возвращает значение true, если вызывающее отображение пусто. В противном случае возвращает false

Set<K> keySet() - возвращает набор, содержащий ключи вызывающего отображения. Метод представляет ключи вызывающего отображения в виде набора

V put(K k, V v) - помещает элемент в вызывающее отображение, переписывая любое предшествующее значение, ассоциированное с ключом.
Возвращает null, если ключ ранее не существовал. В противном случае возвращается предыдущее значение, связанное с ключом.

void putAll(Map<? extends K, ? extends V> m) - помещает все значения из m в отображение

V remove(Object k) - удаляет элемент, ключ которого равен k

int size() - возвращает количество пар "ключ-значение" в отображении

Collection<V> values() - возвращает коллекцию, содержащую значения отображения.

Основные методы - get() и put(), чтобы получить или поместить значения в отображение.

Перебрать элементы map
for (Map.Entry entry : hashMap.entrySet()) {
    System.out.println("Key: " + entry.getKey() + " Value: "
        + entry.getValue());
}


Интерфейс map предоставляет три способа для доступа к данным, используя:
set из ключей (метод getKey)
коллекцию из значений (метод getValues)
set из пары ключ-значение (entrySet)

for (Map.Entry entry: mapName.entrySet()){
    System.out.println(entry.getKey() + " : " + entry.getValue());
}

HashMap - структура данных для хранения связанных вместе пар "ключ-значение".
TreeMap - отображение с отсортированными ключами
EnumMap - отображение с ключами, относящимися к перечислимому типу
LinkedHashMap - отображение с запоминанием порядка, в котором добавлялись элементы
WeakHashMap - отображение со значениями, которые могут удаляться сборщиком мусора, если они больше не используются
IdentityHasMap - отображение с ключами, сравниваемыми с помощью операции == вместо метода equals()

Класс TreeMap расширяет класс AbstractMap и реализует интерфейс NavigatebleMap.
Он создает коллекцию, которая для хранения элементов применяет дерево.
Объекты сохраняются в отсортированном порядке по возрастанию.
Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap блестящим выбором для хранения больших объемов отсортированной информации, которая должна быть быстро найдена.

TreeMap основан на Красно-Черном дереве, вследствие чего TreeMap сортирует элементы по ключу в естественном порядке или на основе заданного вами компаратора.
TreeMap гарантирует скорость доступа log(n) для операций containsKey, get, put и remove.


При попытке добавить null-элемент в TreeMap происходит исключение NullPointerException.
Конструкторы
В классе TreeMap присутствуют следующие конструкторы:

1. TreeMap( )
2. TreeMap(Comparator comp)
3. TreeMap(Map m)
4. TreeMap(SortedMap sm)
Первый конструктор создает коллекцию, в которой все элементы отсортированы в натуральном порядке их ключей.
Второй конструктор создаст пустую коллекцию, элементы в которой будут отсортированы по закону, который определен в передаваемом компараторе.
Третий конструктор создаст TreeMap на основе уже имеющегося Map.
Четвертый конструктор создаст TreeMap на основе уже имеющегося SortedMap , элементы в которой будут отсортированы по закону передаваемой SortedMap .

Для сортировки используются ключи, а не значения.
TreeMap не синхронизирован.


LinkedHashMap расширяет HashMap, допускает нулевые значения и нулевые ключи, не синхронизирован.

LinkedHashMap реализован как двунаправленный список.
LinkedHashMap содержит пары ключ-значение. Порядок, в котором хранятся элементы в LinkedHashMap, определяется порядком установки их в LinkedHashMap (insertion-order).

Производительность LinkedHashMap на основных операциях (add, contains, remove) слегка ниже, чем у HashMap, из-за необходимости поддерживать двунаправленный список,
но время обхода LinkedHashMap пропорционально его размеру (size), т.е. количеству элементов в нём,
тогда как время обхода HashMap пропорционально его ёмкости (capacity).


HashMap
Ключи и значения могут быть любых типов, в том числе и null.
Данная реализация не дает гарантий относительно порядка элементов с течением времени.
Разрешение коллизий осуществляется с помощью метода цепочек.

Map<String, String> hashmap = new HashMap<String, String>();
Новоявленный объект hashmap, содержит ряд свойств:
* table — Массив типа Entry[]
* loadFactor — Коэффициент загрузки
* threshold — Предельное количество
* элементов, при достижении которого,
* размер хэш-таблицы увеличивается вдвое.
* size — Количество элементов HashMap-а;

HashMap имеет внутренний класс Entry (он и хранит пары ключ - значение):
        static class Entry implements Map.Entry
        {
            final K key;
            V value;
            Entry next;
            final int hash;
        //остальной код
       }

Класс Entry имеет Ключ и Значение хранящиеся, как атрибуты.
Ключ помечен как final.
Экземпляры класса Entry хранятся в массиве - класс HashMap определяет эту переменную как: transient Entry[] table;

Работа метода put().

— Первым делом, проверяется существует ли ключ.
Если ключ не существует (null), значение помещается в таблицу на нулевую позицию, потому что хеш-код для значения null, это – всегда 0.

— На следующем шаге, рассчитывается хеш-значение используя хеш-код ключа, получаемый вызовом метода hashCode().
Это хеш-значение используется для вычисления позиции в массиве, куда будет помещен объект Entry.

— Теперь вызывается функция indexFor(hash, table.length), для вычисления точной позиции, куда будет помещен объект Entry.

— Теперь, исходя из того, что – два неравных объекта могут иметь равные значения хеш-кодов, появляется вопрос:
Будут ли два разных объекта помещаться в одинаковую позицию в массиве [корзина]?
Класс Entry имеет атрибут «next». Этот атрибут всегда указывает на следующий объект в цепи.
Итак, объекты Entry хранятся в форме LinkedList. Когда объект Entry должен быть помещен в определенное место,
HashMap проверяет нет ли уже в этом месте записи.
Если записи нету, то объект помещается в данную позицию.
Если все же в данной позиции уже есть объект, проверяется следующий атрибут.
Если он возвращает null и текущий объект Entry становится следующим звеном в LinkedList.
Если следующая переменная не null, процедура повторяется для следующей, пока не найдет null.

Если мы поместим другой объект с другим значением но с тем же ключом, что был ранее -
это приведет к замене старого значения.

Таким образом HashMap гарантирует уникальность всех ключей.
1. Структура данных для хранения в объекте Entry это массив с именем table и типом Entry.
2. Каждая индивидуальная позиция в массиве называется корзина, потому что она может содержать первый элемент LinkedList объектов Entry.
3. hashCode() Ключа требуется для вычисления позиции объекта Entry.
4. equals() Ключа используется для проверки уникальности ключа в карте(map).
5. hashCode() и equals() Значения не используется в методах get() и set() в HashMap.
6. Хеш-код для ключей со значением null это всегда 0. И такой объект Entry всегда будет храниться в нулевой позиции массива.


Упорядочивание Map по значениям

List list = new ArrayList(Map.entrySet());
Collections.sort(list, new Comparator() {

  @Override
  public int compare(Entry e1, Entry e2) {
    return e1.getValue().compareTo(e2.getValue());
  }

});

---------------------------------------------------------------------------------------------------------------------
Коллекция 	        Упорядочивание    Random Access 	Ключ-значение 	Дублирующиеся  	Нулевой   Потокобезопасность
                                                                           элементы     элемент
---------------------------------------------------------------------------------------------------------------------
ArrayList 	                Да 	            Да 	            Нет 	            Да 	        Да 	        Нет
---------------------------------------------------------------------------------------------------------------------
LinkedList 	                Да 	            Нет 	        Нет 	            Да 	        Да 	        Нет
---------------------------------------------------------------------------------------------------------------------
HashSet 	                Нет 	        Нет 	        Нет 	            Нет 	    Да 	        Нет
---------------------------------------------------------------------------------------------------------------------
TreeSet 	                Да 	            Нет 	        Нет 	            Нет 	    Нет 	    Нет
---------------------------------------------------------------------------------------------------------------------
HashMap 	                Нет 	        Да 	            Да 	                Нет         Да 	        Нет
---------------------------------------------------------------------------------------------------------------------
TreeMap 	                Да 	            Да 	            Да 	                Нет 	    Нет 	    Нет
---------------------------------------------------------------------------------------------------------------------
Vector 	                    Да 	            Да 	            Нет 	            Да 	        Да 	        Да
---------------------------------------------------------------------------------------------------------------------
Hashtable 	                Нет 	        Да          	Да 	                Нет 	    Нет 	    Да
---------------------------------------------------------------------------------------------------------------------
Properties 	                Нет 	        Да 	            Да 	                Нет 	    Нет     	Да
---------------------------------------------------------------------------------------------------------------------
Stack 	                    Да 	            Нет 	        Нет 	            Да      	Да      	Да
---------------------------------------------------------------------------------------------------------------------
CopyOnWriteArrayList 	    Да 	            Да 	            Нет 	            Да 	        Да          Да
---------------------------------------------------------------------------------------------------------------------
ConcurrentHashMap 	        Нет 	        Да 	            Да 	                Нет 	    Нет 	    Да
---------------------------------------------------------------------------------------------------------------------
CopyOnWriteArraySet 	    Нет 	        Нет 	        Нет 	            Нет 	    Да 	        Да
---------------------------------------------------------------------------------------------------------------------






