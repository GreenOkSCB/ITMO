------------------класс Object---------------------------------------------

В Java все классы наследуются от Object.
Это позволяет группировать ссылки на объекты и работать с ними единообразно.
Класс Object предоставляет следующие методы, которые есть у всех объектов:
  1) Class<?> getClass() - возвращает ссылку на класс объекта
  2) int hashCode() - возвращает хэш-код объекта, по умолчанию это
    рассчитанное специальным образом число на основании генератора случайных чисел;
  3) boolean equals(Object obj) — возвращает true, если объекты одинаковы,  по умолчанию выполняет сравнение по ссылке: ==;
  4) Object clone() - создает копию объекта;
  5) String toString() - возвращает строковое представление объекта, например для удобства вывода в консоль;
  6) void finalize() - выполняется при уничтожении объекта сборщиком мусора;
  7) методы wait(), notify() и notifyAll() используются при многопоточном программировании.

Для определения идентичности объектов используют методы equals() и hashCode().
Они переопределяются оба для соответсвия следующим требованиям.  (сгенерировать Intellij IDEA: ALT + Insert).
equals:
1. Рефлективность — объект всегда равен самому себе: a.equals(a).
2. Симметричность — если a.equals(b) , то и b.equals(a).
3. Транзитивность — если a.equals(b), b.equals(c), то и a.equals(c).
4. Консистентность — сколько бы раз не вызывался equals без изменения состояния объектов, результат должен оставаться неизменным.
Переопределенный equals проверяет сначала идентичность с помощью ==,
потом на null и тип переданного объекта,
после чего сравнивает при помощи equals все поля

hashCode:
1. Сколько раз бы не был вызван hashCode на объекте, он должен возвращать то же значение. Значение может быть иным при следующем выполении программы.
2. Если объекты равны по equals(), то hashCode() должен вернуть одинаковое значение для обоих объектов.
3. Если объекты не равны по equals(), hashCode() может возвращать одинаковые значения.

------------------Оператор Final---------------------------------------------

Оператор Final
final могут быть
переменные
методы
агрументы методов
локальные переменные методов
классы

переменные final
должны быть инициализированы в момент объявления или в конструкторе класса
нельзя присвоить новое значени переменной final

методы final не могут быть переопределены в наследниках

агрументы методов final доступны только для чтения

классы final не могут иметь наследников

-----------------Оператор Static----------------------------------------------

Static — это ключевое слово в Java.
1. Статические переменные
В Java можно использовать ключевое слово static в переменной класса.
Статическая переменная класса и не принадлежит к объекту/экземпляру класса
Переменные являются общими для всех экземпляров объекта, они не потоко-безопасные.
Обычно статические переменные используются с ключевым словом final для общих ресурсов или констант, которые могут быть использованы всеми объектами.
Если статическая переменная не является private, то получить к ней доступ можно следующим способом: ClassName.staticVarName

2. static методы.
Как и статические переменные, статические методы принадлежат классу, а не к экземплярам класса.
Статический метод может получить доступ только к статическим переменным класса и вызывать только статические методы класса.
Обычно статические методы являются утилитными (вспомогательными) методами, которые должны быть использованы другими классами без необходимости создания экземпляра.
Доступ к статическому методу: ClassName.staticMethodName

Начиная с Java 8, можно использовать статические методы и в интерфейсах.
Начиная с девятой версии, можно создавать private static методы в интерфейсах с помощью private.

3. Cтатический блок:
static блок c группой операторов используется для инициализации статических переменных класса.
В основном он используется для создания статических ресурсов, когда класс загружается.
Мы не можем получить доступ к не-статическим переменным в статическом блоке.
Мы можем иметь несколько статических блоков в классе, хотя это не имеет особого смысла.
Статический блок кода выполняется только один раз, когда класс загружается в память.

static{
    //можем ресурсы, когда блок загружен
    //можем получить доступ только к статическим переменным и методам
}

4. Статический класс в Java
Можно использовать ключевое слово static с вложенными классами.
Ключевое слово static не может быть использовано с классами верхнего уровня.

-----------------Вложенные и внутренние классы----------------------------------------------
Определение класса может размещаться внутри определения другого класса. Такие классы называются вложенными или внутренними.
Область видимости вложенного класса ограничена областью видимости внешнего класса.
Поэтому, если вы создадите класс B внутри класса A, то класс B не сможет существовать независимо от класса A.

Вложенные классы позволяют группировать классы, логически принадлежащие друг другу, и управлять доступом к ним.

Если связь между объектом внутреннего класса и объектом внешнего класса не нужна, можно сделать внутренний класс статическим (static).
Такой класс называют вложенным (nested).
Статический вложенный класс (nestedInnerClass)
public class OuterClass {
    public static class StaticInnerClass{
    }
}

Из него (самого класса) видны:
— статические свойства и методы OuterClassа (даже private).
— статические свойства и методы родителя OuterClassа public и protected. То есть те, которые видны в OuterClassе.

Из его экземпляра видны:
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

Его видно:
— согласно модификатору доступа.

Может наследовать:
— обычные классы.
— такие же статические внутренние классы в OuterClassе и его предках.

Может быть наследован:
— любым классом:
— вложенным
— не вложенным
— статическим
— не статическим!

Может имплементировать интерфейс

Может содержать:
— статические свойства и методы.
— не статические свойства и методы.

Экзэмпляр этого класса создаётся так:

OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();


Нестатические вложенные классы называют также внутренними классами (inner).
Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них.

Вложенный класс (InnerClass)
public class OuterClass {
    public class InnerClass{
    }
}

Из него видны:
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

Его видно:
— согласно модификатору доступа.

Может наследовать:
— обычные классы.
— такие же внутренние классы в OuterClassе и его предках.

Может быть наследован:
— таким же внутренним классом в OuterClassе и его наследниках.

Может имплементировать интерфейс

Может содержать:
— только обычные свойства и методы (не статические).

Экзэмпляр этого класса создаётся:
OuterClass outerClass = new OuterClass();
OuterClass.InnerClass innerClass = outerClass.new InnerClass();

-----------------Локальные классы----------------------------------------------
Классы, созданные внутри метода
Локальный класс (LocalClass)
public class OuterClass {
    public void someMethod(){
        class LocalClass{
        }
    }
}

Из него видны:
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

Его видно:
— только в том методе где он определён.

Может наследовать:
— обычные классы.
— внутренние классы в OuterClassе и его предках.
— такие же локальные классы определённые в том же методе.

Может быть наследован:
— таким же локальным классом определённом в том же методе.

Может имплементировать интерфейс

Может содержать:
— только обычные свойства и методы (не статические).

-----------------Анонимные классы----------------------------------------------

Локальный класс без имени. Наследует какой-то класс, или имплиментирует какой-то интерфейс.
interface SomeInterface {
    String coolString();
}
public class OuterClass {
    public void someMethod(){
        SomeInterface callable = new SomeInterface() {
            @Override
            public String coolString(){
                return "cool string";
            }
        };
    }
}
Из него видны:
— все (даже private) свойства и методы OuterClassа обычные и статические.
— public и protected свойства и методы родителя OuterClassа обычные и статические. То есть те, которые видны в OuterClassе.

Его видно:
— только в том методе где он определён.

Не может быть наследован

Может содержать:
— только обычные свойства и методы (не статические).


